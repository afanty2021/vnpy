[根目录](../../../CLAUDE.md) > [vnpy](../../) > **rpc**

# RPC - 远程过程调用

> 更新时间：2025-12-09 11:33:34

## 模块职责

RPC模块提供了基于ZeroMQ的远程过程调用功能，支持VeighNa系统的分布式部署。可用于构建客户端-服务器架构，实现数据服务和交易执行的网络化。

## 入口与启动

### 主要入口
- `RpcServer` - RPC服务器
- `RpcClient` - RPC客户端

### 服务器启动
```python
from vnpy.rpc import RpcServer

# 创建服务器
server = RpcServer("tcp://*:5000")

# 注册函数
@server.register
def add(a: int, b: int) -> int:
    return a + b

# 启动服务器
server.start()
```

### 客户端连接
```python
from vnpy.rpc import RpcClient

# 创建客户端
client = RpcClient("tcp://localhost:5000")

# 调用远程函数
result = client.add(1, 2)  # 返回 3
```

## 对外接口

### RpcServer接口
- `start()` - 启动服务器
- `stop()` - 停止服务器
- `register()` - 注册可远程调用的函数
- `unregister()` - 注销函数

### RpcClient接口
- `__getattr__` - 动态获取远程函数代理
- `call()` - 直接调用远程函数

## 关键依赖与配置

### 核心依赖
- `pyzmq` - ZeroMQ Python绑定
- `pickle` - 对象序列化

### 通信协议
- **REP/REQ模式**：请求-响应模式
- **序列化**：使用pickle进行对象序列化
- **传输层**：TCP协议

## 数据模型

### 消息格式
- **请求**：函数名、参数、调用ID
- **响应**：结果数据、错误信息、调用ID

### 支持的数据类型
- Python基本类型：int, float, str, bool
- 容器类型：list, dict, tuple
- 自定义对象：通过pickle序列化
- 特殊类型：None, datetime等

## 实现机制

### 通信流程
1. 客户端序列化函数调用请求
2. 通过ZeroMQ发送到服务器
3. 服务器反序列化并执行函数
4. 序列化结果并返回
5. 客户端接收并反序列化结果

### 异常处理
- 服务器端异常会传播到客户端
- 网络异常会抛出连接错误
- 支持超时设置

## 性能特点

### 优势
- 轻量级实现，无额外依赖
- 支持函数式编程模型
- 自动处理序列化/反序列化
- 异步IO，高并发支持

### 性能限制
- Pickle序列化有性能开销
- 不适合传输大量数据
- 网络延迟影响响应时间

## 安全考虑

### 当前限制
- 无内置认证机制
- 无加密传输
- 无访问控制

### 建议措施
- 使用VPN或专用网络
- 在服务器端实现认证
- 限制可注册的函数范围

## 扩展场景

### 分布式架构
- 数据服务器：集中存储和管理历史数据
- 交易服务器：统一执行交易指令
- 策略服务器：运行计算密集型策略

### 监控和管理
- 远程监控系统状态
- 远程配置参数更新
- 远程日志收集

## 常见问题 (FAQ)

### Q: 如何处理大对象传输？
A: 避免传输大对象，改用共享存储或数据库。

### Q: 如何实现服务器推送？
A: 使用ZeroMQ的PUB/SUB模式，或客户端轮询。

### Q: 如何保证调用的幂等性？
A: 在服务器端实现去重机制或使用唯一ID。

## 相关文件清单

- `__init__.py` - 模块导出
- `server.py` - RpcServer实现
- `client.py` - RpcClient实现
- `common.py` - 通用定义

## 变更记录 (Changelog)

### 2025-12-09 11:33:34
- ✨ 创建rpc模块文档
- 📊 整理RPC架构设计
- 🔧 说明核心接口和使用场景
- 📝 添加安全注意事项和扩展建议

---

*提示：该模块适合构建内部系统的分布式部署，不推荐直接暴露到公网。*